====================
Fitting a powerlaw
====================


Data
--------

In data.stan.rdata:

N <- 100
logsamples <- c(9.18992051416,9.07123590875,10.9708347932,9.2597575302,9.41670222852,9.51730836947,9.36493995426,9.23073781047,9.20073196859,9.13427946244,9.18879220459,9.08208514306,9.34470405312,9.02822369958,9.78122306578,9.08681113127,9.18977330869,9.12641461768,9.42633664824,9.35155612998,9.0482529992,9.00700365113,9.25193375212,9.07984574067,9.02865150333,9.02418393565,9.53517762089,9.70416288417,9.38499225874,9.02821750091,9.50361980857,9.18780344736,9.0093422868,9.13656906788,9.07998551742,9.25048956022,9.08167943578,9.03925413057,9.86891360038,9.06242758887,9.002432356,9.0630011163,9.27607692971,9.0513846357,9.49310543677,9.17441260739,9.02081470848,9.26611151046,9.27047321322,9.44298060327,9.85646929609,9.08411771653,9.33721331715,9.28792957886,9.15420591917,9.6363817325,9.12049956758,9.41674265025,9.11482973921,9.07752595215,9.49498911504,9.19147046524,9.07919509459,9.19140582109,9.65071721719,9.13545957781,9.08898312767,9.14414314587,9.01237723489,9.1158456144,9.02205949652,9.43088860314,9.42806131591,9.04645797034,9.20023485206,9.39079238855,9.01634103201,9.22935652751,9.06223436757,9.06953229223,9.02694438735,9.10252180457,9.062196677,9.22865054719,9.28437611864,9.02387357215,9.18423185493,9.00777233939,9.08909868357,9.10321106117,9.47013127361,9.01125497197,9.17343614719,9.11888975694,9.194597121,9.31260110821,9.02206487952,9.12066533956,10.2710343095,9.10480642301)

This was generated by the generate_data.py script.


Model
---------

In powerlaw.stan::

	data {
		int N;
		vector[N] logsamples;
	}
	transformed data {
		vector[N] samples;
		
		for (i in 1:N) {
			samples[i] <- pow(10, logsamples[i]);
		}
	}
	parameters {
		real<lower=0,upper=10> loglo;
		real<lower=-10, upper=0> slope;
	}
	model {
		samples ~ pareto(pow(10, loglo), -slope);
	}



Fairly straightforward. The data are transformed from log to real space.

The model parameters are the powerlaw slope and the minimal value.
The likelihood is defined by saying the samples are pareto (powerlaw) distributed.

Running
-----------

Build the program::

	make -C pathtoyour/cmdstan/ $PWD/powerlaw

Run the program::

	./powerlaw data file=data.stan.rdata output file=powerlaw_output.csv sample


Output
---------------

powerlaw_output.csv now contains::

	...
	lp__,accept_stat__,stepsize__,treedepth__,n_leapfrog__,n_divergent__,loglo,slope
	...
	-2366.79,0.888888,0.0263503,4,9,1,9.00168,-8.0372
	-2367.48,0.964285,0.0263503,5,28,1,9.00126,-8.03529
	-2367.34,1,0.0263503,3,7,0,9.00133,-8.03521
	-2366.78,0.923077,0.0263503,4,13,1,9.00162,-8.03436
	-2366.16,0.8,0.0263503,3,5,1,9.00194,-8.03394
	-2366.02,0.857143,0.0263503,3,7,1,9.00201,-8.03361
	...

Most of the columns we can ignore. The last two are samples of our two model parameters.

Lets plot the slope samples:
	
	.. image:: sampling_1000.png


Stan is slowly converging towards the true value (-2). 
We need to either give better prior limits or run longer!

Longer sampling:

	.. image:: sampling_10000.png

This is better.

The trick is to tell Stan to do a longer warm-up, with::

	./powerlaw data file=data.stan.rdata output file=powerlaw_output.csv sample num_warmup=10000 num_samples=10000

This gives a well-sampled posterior:

	.. image:: sampling_long_warmup.png
	.. image:: posterior_long_warmup.png

The true valus were -2 and 9, and this falls well within the samples.


